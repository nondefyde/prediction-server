import * as mongoose from 'mongoose';
import slugify from 'slugify';
import { v4 as uuidv4 } from 'uuid';
import * as _ from 'lodash';
import * as dateFns from 'date-fns';
import { Between } from 'typeorm';

export class Utils {
  public static generateRandomNumber(length): number {
    // Generate a random {length} digit code
    return Math.floor(
      Math.pow(10, length - 1) + Math.random() * Math.pow(10, length - 1) * 9,
    );
  }

  public static capitaliseFirst(str: string): string {
    // Generate a random {length} digit code
    return `${str[0].toUpperCase()}${str.substring(1)}`;
  }

  public static checkBooleanValue(str) {
    // Convert the string to lowercase for case-insensitive comparison
    const lowercased = str.toLowerCase();
    if (lowercased === 'true') {
      return true;
    } else if (lowercased === 'false') {
      return false;
    } else {
      return false;
    }
  }

  /**
   * @param {Number} min
   * @return {Date} The date
   */
  public static addMinToDate(min = 1) {
    const date = new Date();
    const minutes = date.getMinutes() + min;
    date.setMinutes(minutes);
    return date;
  }

  /**
   * @param {Number} hour
   * @return {Date} The date
   */
  public static addHourToDate(hour = 1) {
    const date = new Date();
    const hours = date.getHours() + hour;
    date.setHours(hours);
    return date;
  }

  /**
   * Get Auto Generated Random Password
   *
   * @param   int     length, eg: Default Length = 10
   *
   * @return  string  Auto generated random password
   */
  public static getAutoGeneratedPassword = (length = 10) => {
    const charset =
      'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let genPass = '';

    for (let i = 0, n = charset.length; i < length; ++i) {
      genPass += charset.charAt(Math.floor(Math.random() * n));
    }

    return genPass;
  };

  /**
   * @param {Number} size Code length
   * @return {String} The passcode
   */
  static getAutoGeneratedPasscode = (size = 8) => {
    const characters = '0123456789';
    const charactersArray = characters.split('');
    let selections = '';
    for (let i = 0; i < size; i++) {
      const index = Math.floor(Math.random() * charactersArray.length);
      selections += charactersArray[index];
      charactersArray.splice(index, 1);
    }
    return selections;
  };

  /**
   * @param {Number} size Code length
   * @param {Boolean} alpha Check if it's alpha numeral
   * @return {String} The code
   */
  static generateOTCode = (size = 6, alpha = false) => {
    const characters = alpha
      ? '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
      : '0123456789';
    const charactersArray = characters.split('');
    let selections = '';
    for (let i = 0; i < size; i++) {
      const index = Math.floor(Math.random() * charactersArray.length);
      selections += charactersArray[index];
      charactersArray.splice(index, 1);
    }
    return selections;
  };

  /**
   * @param {String} key the prefix for the id
   * @param {Number} length the length of the id
   * @return {Date} The date
   */
  static generateUniqueId(key: string) {
    return `${key || 'key'}-${uuidv4()}`;
  }

  /**
   * Convert callback to promise;
   *  @param {String} text
   * @return {String} params date
   */
  static slugifyText = (text) => {
    if (text === null || typeof text === 'undefined') {
      return text;
    }
    if (text.indexOf(' ') >= 0) {
      return slugify(text.toLowerCase(), '-');
    }
    return text.toLowerCase();
  };

  /**
   * convert to uppercase 1st letter
   * @param value
   * @return {Boolean} The code
   */
  static IsObjectId(value) {
    try {
      return (
        value &&
        value.length > 12 &&
        String(new mongoose.Types.ObjectId(value)) === String(value)
      );
    } catch (e) {
      return false;
    }
  }

  /**
   * Add days to a date
   * @param {Date} date The date
   * @param days days to add
   * @return {Boolean} The code
   */
  static addDays(date, days) {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  }

  /**
   * modifies mobile with isocode
   * @param {String} mobile
   * @return {String} mobileNoT
   */
  static cleanUpMobileNumber(mobile) {
    let mobileNo = mobile.toString().trim();
    if (mobileNo.substring(0, 1) === '0' && mobileNo.length === 11) {
      mobileNo = `234${mobileNo.substring(1)}`;
    } else if (mobileNo.substring(0, 1) !== '+') {
      mobileNo = `${mobileNo}`;
    }
    // return '2348075889776'
    return mobileNo;
  }

  /**
   * @param {Object} object The payload object
   * @param {String} key to be updated,
   * @return {Object}
   */
  static updateVerification(object, key) {
    const verifications = {
      ...object.verifications,
      [key]: true,
    };
    const verificationCodes = _.omit(
      {
        ...object.verificationCodes,
      },
      [key],
    );
    return { verifications, verificationCodes };
  }

  /**
   * {Date} Generate date range of a single date based on start and end of day
   */
  public static generateSingleDateRange(date: string, dbType = 'NoSQL') {
    const startDate = dateFns.startOfDay(dateFns.parseISO(date));
    const endDate = dateFns.endOfDay(dateFns.parseISO(date));

    return dbType === 'NoSQL'
      ? { $gte: startDate, $lte: endDate }
      : Between(startDate, endDate);
  }

  /**
   * Generate date range based on give start and end dates
   */
  public static generateDateRange(obj: any, dbType = 'NoSQL') {
    try {
      const dateRange = JSON.parse(obj);
      if (dateRange && dateRange.startDate && dateRange.endDate) {
        const startDate = dateFns.startOfDay(
          dateFns.parseISO(dateRange.startDate),
        );
        const endDate = dateFns.endOfDay(dateFns.parseISO(dateRange.endDate));
        return dbType === 'NoSQL'
          ? { $gte: startDate, $lte: endDate }
          : Between(startDate, endDate);
      }
      return this.generateSingleDateRange(
        dateRange.startDate || dateRange.endDate || new Date(obj),
        dbType,
      );
    } catch (e) {
      return this.generateSingleDateRange(obj, dbType);
    }
  }

  /**
   * @param {String} duration
   * @return {Date} The date
   */
  public static getSubscription(duration: string) {
    const subscriptionLengthInMonths = this.getMonths(duration);

    const today = new Date();

    const startOfDay = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate(),
      0,
      0,
      0,
    );

    const endOfDay = new Date(
      today.getFullYear(),
      today.getMonth() + subscriptionLengthInMonths,
      today.getDate(),
      23,
      59,
      59,
    );

    return {
      startDate: startOfDay,
      endDate: endOfDay,
    };
  }

  /**
   * @param {String} duration
   * @return {Date} The date
   */
  public static getMonths(duration) {
    if (duration === 'monthly') {
      return 1;
    }
    if (duration === 'quarterly') {
      return 3;
    }
    if (duration === 'yearly') {
      return 12;
    }
    return 0;
  }

  public static generateStartDateAndEndDate = () => {
    const today = new Date();
    const date = today.getDate();
    const month = today.getMonth() + 1;
    const year = today.getFullYear();

    const formattedDate =
      year +
      '-' +
      (month < 10 ? '0' : '') +
      month +
      '-' +
      (date < 10 ? '0' : '') +
      date;

    return {
      startDate: formattedDate,
      endDate: formattedDate,
    };
  };

  /**
  * @param {String} value
  * @return {Date} The date
  */
  public static getDateFromValue(value: string) {
    const currentDate = new Date();

    switch (value) {
      case 'week':
        const beginningOfWeek = new Date(currentDate.setDate(currentDate.getDate() - currentDate.getDay()));
        // const formattedDate = beginningOfWeek.toISOString();
        return beginningOfWeek;

      case 'month':
        currentDate.setDate(1);
        const beginningOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
        return beginningOfMonth;

      case 'quarter':
        const currentQuarter = Math.floor(currentDate.getMonth() / 3) + 1;
        const beginningOfQuarter = new Date(currentDate.getFullYear(), (currentQuarter - 1) * 3, 1);
        return beginningOfQuarter;

      case 'year':
        const beginningOfYear = new Date(currentDate.getFullYear(), 0, 1);
        return beginningOfYear

      default:
        return null;
    }
  }

  /**
* @param {String} value
* @return {Date} The date
*/
  public static getDateRangeFromValue(value: string) {
    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const dates: { startDate: Date, endDate: Date }[] = [];

    switch (value) {
      case 'week':
        currentDate.setHours(0, 0, 0, 0);

        for (let i = 0; i < 4; i++) {
          const startDate = new Date(currentDate);
          startDate.setDate(startDate.getDate() - startDate.getDay());

          const endDate = new Date(startDate);
          endDate.setDate(endDate.getDate() + 6);
          endDate.setHours(23, 59, 59, 999);

          dates.push({ startDate, endDate });

          currentDate.setDate(currentDate.getDate() - 7);
        }

        return dates;

      case 'month':
        currentDate.setHours(0, 0, 0, 0);

        for (let i = 0; i < 4; i++) {
          const startDate = new Date(currentDate);
          startDate.setMonth(startDate.getMonth() - i);

          const endDate = new Date(startDate);
          endDate.setMonth(endDate.getMonth() + 1);
          endDate.setDate(endDate.getDate() - 1);
          endDate.setHours(23, 59, 59, 999);

          dates.push({ startDate, endDate });
        }

        return dates;

      case 'quarter':
        for (let quarter = 1; quarter <= 4; quarter++) {
          const startMonth = (quarter - 1) * 3;
          const startDate = new Date(currentYear, startMonth, 1);
          startDate.setHours(0, 0, 0, 0);

          const endMonth = startMonth + 2;
          const endDate = new Date(currentYear, endMonth + 1, 0);
          endDate.setHours(23, 59, 59, 999);

          dates.push({ startDate, endDate });
        }

        return dates;

      case 'year':
        for (let i = 0; i < 4; i++) {
          const startYear = currentYear - i;
          const startDate = new Date(startYear, 0, 1);
          startDate.setHours(0, 0, 0, 0);

          const endDate = new Date(startYear, 11, 31);
          endDate.setHours(23, 59, 59, 999);

          dates.push({ startDate, endDate });
        }

        return dates;

      default:
        return null;
    }
  }
}
